<html>
	<head>
		<script type="text/javascript" src="../js/coverreport.js">

		</script><script type="text/javascript">
			RANGES_44 = [
   [49,8,49,9,'dccv']
, [49,10,49,36,'dccv']
, [49,37,49,38,'dccv']
, [57,3,57,4,'dccv']
, [58,4,59,22,'dccv']
, [60,63,60,65,'dccv']
, [62,4,63,20,'dccv']
, [64,132,64,137,'dccv']
, [66,4,66,26,'dccv']
, [67,3,67,4,'dccv']
, [74,3,74,4,'dccv']
, [75,4,81,7,'dccv']
, [83,4,83,26,'dccv']
, [84,3,84,4,'dccv']
, [91,3,91,4,'dccv']
, [92,4,92,35,'dccv']
, [92,36,92,81,'dccv']
, [94,4,95,24,'dccv']
, [95,47,96,25,'dccv']
, [97,3,97,4,'dccv']
, [100,3,100,4,'dccv']
, [101,4,101,34,'dccv']
, [102,4,102,23,'dccv']
, [104,4,104,57,'dccv']
, [105,4,105,29,'dccv']
, [107,4,107,44,'dccv']
, [108,4,108,50,'dccv']
, [110,4,110,67,'dccv']
, [111,4,111,100,'dccv']
, [112,4,112,38,'dccv']
, [114,4,123,14,'dccv']
, [124,3,124,4,'dccv']
, [127,3,127,4,'dccv']
, [128,4,128,61,'dccv']
, [129,4,129,32,'dccv']
, [131,4,131,55,'dccv']
, [132,4,132,51,'dccv']
, [133,4,133,23,'dccv']
, [135,4,135,52,'dccv']
, [136,4,136,58,'dccv']
, [138,4,138,47,'dccv']
, [139,3,139,4,'dccv']
, [142,3,142,4,'dccv']
, [143,4,143,44,'dccv']
, [144,3,144,4,'dccv']
, [147,3,147,4,'dccv']
, [148,4,148,80,'dccv']
, [149,3,149,4,'dccv']
, [152,3,152,4,'dccv']
, [153,4,153,65,'dccv']
, [154,4,154,38,'dccv']
, [154,39,154,134,'dccv']
, [155,4,155,27,'dccv']
, [155,28,155,86,'dccv']
, [156,4,156,16,'dccv']
, [157,3,157,4,'dccv']
, [59,22,59,41,'dccv']
, [60,28,60,37,'dccv']
, [60,48,60,63,'dccv']
, [95,24,95,47,'dccv']
, [39,3,39,124,'dccv']
, [161,59,161,65,'dccv']
, [162,4,162,5,'dccv']
, [163,5,163,21,'dccv']
, [164,5,164,27,'dccv']
, [165,4,165,5,'dccv']
, [63,20,64,22,'dccv']
, [64,132,64,134,'dccv']
, [64,22,64,132,'dccv']
, [102,24,102,36,'dcuc']
, [105,30,105,42,'dcuc']
, [129,33,129,59,'dcuc']
, [133,24,133,50,'dcuc']
];
		</script><link rel="stylesheet" type="text/css" href="../css/coverreport.css" />
	</head><body>
		<code id="src44" class="dotCoverSource"><pre>// Copyright (c) 2013, The Tribe
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
// 
//  * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
// 
//  * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using System.Xml.Linq;

namespace HBase.Stargate.Client.MimeConversion
{
	/// &lt;summary&gt;
	///    Defines an XML implementation of &lt;see cref=&quot;IMimeConverter&quot; /&gt;.
	/// &lt;/summary&gt;
	public class XmlMimeConverter : MimeConverterBase
	{
		private const string _cellSetName = &quot;CellSet&quot;;
		private const string _rowName = &quot;Row&quot;;
		private const string _keyName = &quot;key&quot;;
		private const string _columnFormat = &quot;{0}:{1}&quot;;
		private const string _columnName = &quot;column&quot;;
		private const string _qualifierName = &quot;qualifier&quot;;
		private const string _timestampName = &quot;timestamp&quot;;
		private const string _cellName = &quot;Cell&quot;;
		private const string _columnParserFormat = &quot;(?&lt;{0}&gt;[^:]+):(?&lt;{1}&gt;.+)?&quot;;
		private static readonly Regex _columnParser = new Regex(string.Format(_columnParserFormat, _columnName, _qualifierName));

		/// &lt;summary&gt;
		///    Gets the current MIME type.
		/// &lt;/summary&gt;
		/// &lt;value&gt;
		///    The MIME type.
		/// &lt;/value&gt;
		public override string MimeType
		{
			get { return HBaseMimeTypes.Xml; }
		}

		/// &lt;summary&gt;
		///    Converts the specified cells to text according to the current MIME type.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;cells&quot;&gt;The cells.&lt;/param&gt;
		public override string Convert(IEnumerable&lt;Cell&gt; cells)
		{
			IDictionary&lt;string, Cell[]&gt; rows = cells
				.GroupBy(cell =&gt; cell.Identifier.Row)
				.ToDictionary(group =&gt; group.Key, group =&gt; group.ToArray());

			XElement xml = XmlForCellSet(rows.Keys
				.Select(row =&gt; XmlForRow(row, rows[row]
					.Select(cell =&gt; XmlForCell(cell.Identifier.Cell.Column, cell.Identifier.Cell.Qualifier, cell.Identifier.Timestamp, cell.Value)))));

			return xml.ToString();
		}

		/// &lt;summary&gt;
		///    Converts the specified cell to text according to the current MIME type.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;cell&quot;&gt;&lt;/param&gt;
		public override string Convert(Cell cell)
		{
			XElement xml = XmlForCellSet(new[]
			{
				XmlForRow(cell.Identifier.Row, new[]
				{
					XmlForCell(cell.Identifier.Cell.Column, cell.Identifier.Cell.Qualifier, cell.Identifier.Timestamp, cell.Value)
				})
			});

			return xml.ToString();
		}

		/// &lt;summary&gt;
		/// Converts the specified data to a set of cells according to the current MIME type.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;data&quot;&gt;The data.&lt;/param&gt;
		public override IEnumerable&lt;Cell&gt; Convert(string data)
		{
			if (string.IsNullOrEmpty(data)) return new CellSet(Enumerable.Empty&lt;Cell&gt;());

			return XElement.Parse(data).Elements(_rowName)
				.SelectMany(row =&gt; row.Elements(_cellName))
				.Select(CellForXml);
		}

		private static Cell CellForXml(XElement cell)
		{
			XElement parent = cell.Parent;
			if (parent == null) return null;

			XAttribute keyAttribute = parent.Attribute(_keyName);
			if (keyAttribute == null) return null;

			string row = Decode(keyAttribute.Value);
			ParsedColumn parsedColumn = ParseColumn(cell);

			XAttribute timestampAttribute = cell.Attribute(_timestampName);
			long? timestamp = timestampAttribute != null ? timestampAttribute.Value.ToNullableLong() : null;
			string value = Decode(cell.Value);

			return new Cell(new Identifier
			{
				Row = row,
				Cell = new HBaseCellDescriptor
				{
					Column = parsedColumn.Column,
					Qualifier = parsedColumn.Qualifier
				},
				Timestamp = timestamp
			}, value);
		}

		private static ParsedColumn ParseColumn(XElement cell)
		{
			XAttribute columnAttribute = cell.Attribute(_columnName);
			if (columnAttribute == null) return new ParsedColumn();

			string columnValue = Decode(columnAttribute.Value);
			Match match = _columnParser.Match(columnValue);
			if (!match.Success) return new ParsedColumn();

			string column = match.Groups[_columnName].Value;
			string qualifier = match.Groups[_qualifierName].Value;

			return new ParsedColumn(column, qualifier);
		}

		private static XElement XmlForCellSet(IEnumerable&lt;XElement&gt; rows)
		{
			return new XElement(_cellSetName, rows);
		}

		private static XElement XmlForRow(string row, IEnumerable&lt;XElement&gt; cells)
		{
			return new XElement(_rowName, new XAttribute(_keyName, Encode(row)), cells);
		}

		private static XElement XmlForCell(string column, string qualifier, long? timestamp, string value)
		{
			var cell = new XElement(_cellName, new XText(Encode(value)));
			if (!string.IsNullOrEmpty(column)) cell.Add(new XAttribute(_columnName, Encode(string.Format(_columnFormat, column, qualifier))));
			if (timestamp.HasValue) cell.Add(new XAttribute(_timestampName, timestamp.Value));
			return cell;
		}

		private struct ParsedColumn
		{
			public ParsedColumn(string column, string qualifier) : this()
			{
				Column = column;
				Qualifier = qualifier;
			}

			public string Column { get; private set; }
			public string Qualifier { get; private set; }
		}
	}
}</pre></code><script type="text/javascript">
			applyranges('src44', RANGES_44)
		</script>
	</body>
</html>